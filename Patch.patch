diff --git a/IMPLEMENTATION_PLAN.md b/IMPLEMENTATION_PLAN.md
index 76d9a4e..57cc0e9 100644
--- a/IMPLEMENTATION_PLAN.md
+++ b/IMPLEMENTATION_PLAN.md
@@ -1,33 +1,39 @@
-# IMPLEMENTATION_PLAN.md
-
-# Implementation Plan — Narrative Path Splitter
-
-## Phase 0 — Repo hygiene
-
-* [ ] Add `GtSpecSetMarkdownParserAdapter` package.
-* [ ] Baseline adds parser package + depends on `Gt4Nix` (registry) if needed.
-* [ ] Examples class with red→green tests.
-
-## Phase 1 — Parser core
-
-* [ ] `matches:` scans file for any of `^# SPEC$`, `^# IMPLEMENTATION_PLAN$`, `^# RESEARCH$`, `^# WORKLOG$` (case-sensitive for now).
-* [ ] `priority` = 2.
-* [ ] `parse:` extracts sections into `{ spec, plan, research, worklog }`.
-
-## Phase 2 — File writer
-
-* [ ] Write out each part to `SPEC.md`, `IMPLEMENTATION_PLAN.md`, `RESEARCH.md`, `WORKLOG.md`.
-* [ ] Create skeletons for missing sections.
-* [ ] Idempotence (no-op when unchanged).
-
-## Phase 3 — GT integration
-
-* [ ] Register adapter in `GtInputParserRegistry defaultParserSymbols`.
-* [ ] `GtInputFile>>candidateParsers` path is used (already available in Gt4Nix).
-* [ ] Example: winner check; example: selection explanation; example: end-to-end split to files.
-
-## Phase 4 — Nice to have
-
-* [ ] Optional YAML front-matter capture (ignored by default).
-* [ ] Option to choose output directory.
-* [ ] Merge strategy hooks.
+# Implementation Plan — WOW–Narrative Paths
+
+## Phase 0 — Repo & DevShell (Day 0–1)
+- Monorepo `wow-narrative/`:
+  - `dmx-schema/` (types + seed)
+  - `path-api/` (Fastify, ESM, TS)
+  - `fedwiki-plugin-narrative/`
+  - `elm-ui/`
+  - `infra/` (flake.nix, .envrc, docker-compose for DMX)
+- DevShell: Node 22/24, Elm 0.19.1, jq, graphviz, repomix-tools.
+
+## Phase 1 — Data & Fixtures (Day 2–4)
+- DMX types: `Narrative`, `Semantic`, `Variant`.
+- Seed fixture: 12–20 nodes, ≥2 flows, 4+ transitions, variant group for a proof (`difficulty=medium|high`). :contentReference[oaicite:16]{index=16}
+
+## Phase 2 — Adaptation Engine (Day 5–8)
+- **Substitution (variants):** implement “hole” filling by ranking variant sets vs. Λ (variant sorter). :contentReference[oaicite:17]{index=17}
+- **Reordering (structure):** implement narrative ordering; fallback semantic ordering; final fallback context ordering. :contentReference[oaicite:18]{index=18}
+- **Traversal:** longest simple narrative path + match scoring (avg node weights); semantic fallback; append with de-dup. :contentReference[oaicite:19]{index=19}
+- Endpoints: `POST /select`, `GET /flows/:topicId`.
+
+## Phase 3 — FedWiki + Elm (Day 9–12)
+- Inline plugin: query API; render transitions; flow/context switchers.
+- Elm state + ports; ToC; progressive render.
+
+## Phase 4 — Polish & Demo (Day 13–14)
+- i18n transitions; caching; WOW notes & screencast.
+
+## Tests
+- Unit: variant ranking, simple-path constraint, scoring/tie-breaks, dedup append.
+- Integration: two flows; semantic fallback when narrative gaps exist; context flip changes selected variant.
+
+## DoD
+- Demo: switch flows and contexts live; transitions render; fixtures reproducible with `nix develop && npm run demo`.
+
+## Risks/Mitigations
+- Sparse transitions → seed stock transitions (“Next, we …”). :contentReference[oaicite:20]{index=20}
+- Conflicting contexts → deterministic priority in Λ; log decision trace.
+- Graph cycles → visited set; max path length.
diff --git a/docs/fixtures/wow-narrative-fixture.json b/docs/fixtures/wow-narrative-fixture.json
new file mode 100644
index 0000000..d8a1a87
--- /dev/null
+++ b/docs/fixtures/wow-narrative-fixture.json
@@ -0,0 +1,147 @@
+{
+  "meta": {
+    "name": "WOW Narrative Fixture",
+    "start": "T:Intro",
+    "flows": ["intro-defn-proof", "walkthrough"],
+    "notes": "Minimal graph with one variant group (proof difficulty)."
+  },
+  "topics": [
+    {
+      "id": "T:Intro",
+      "type": "Section",
+      "title": "Why Eigenvectors?",
+      "context": { "level": "beginner", "language": "en" },
+      "content": "Motivation and overview."
+    },
+    {
+      "id": "T:Def:Eigenvector",
+      "type": "Definition",
+      "title": "Definition of Eigenvector",
+      "context": { "level": "beginner", "language": "en" },
+      "content": "Ax = λx with x ≠ 0."
+    },
+    {
+      "id": "T:Thm:Spectral",
+      "type": "Theorem",
+      "title": "Spectral Theorem (symmetric case)",
+      "context": { "level": "advanced", "language": "en" },
+      "content": "Every real symmetric matrix is orthogonally diagonalizable."
+    },
+    {
+      "id": "T:Proof:Spectral:medium",
+      "type": "Proof",
+      "title": "Proof (Sketch)",
+      "variantOf": "V:Proof:Spectral",
+      "variant": { "varKey": "difficulty", "varValue": "medium" },
+      "context": { "level": "beginner", "language": "en" },
+      "content": "Sketch using quadratic forms and orthogonal bases."
+    },
+    {
+      "id": "T:Proof:Spectral:high",
+      "type": "Proof",
+      "title": "Proof (Full)",
+      "variantOf": "V:Proof:Spectral",
+      "variant": { "varKey": "difficulty", "varValue": "high" },
+      "context": { "level": "advanced", "language": "en" },
+      "content": "Full argument via the spectral decomposition of self-adjoint operators."
+    },
+    {
+      "id": "T:Ex:Diagonalization",
+      "type": "Example",
+      "title": "Diagonalizing a 2×2 symmetric matrix",
+      "context": { "level": "beginner", "language": "en" },
+      "content": "Compute eigenpairs; form Q; show QᵀAQ = D."
+    }
+  ],
+  "variantGroups": [
+    {
+      "id": "V:Proof:Spectral",
+      "varKey": "difficulty",
+      "members": [
+        { "topic": "T:Proof:Spectral:medium", "varValue": "medium", "context": { "level": "beginner" } },
+        { "topic": "T:Proof:Spectral:high",   "varValue": "high",   "context": { "level": "advanced" } }
+      ]
+    }
+  ],
+  "associations": [
+    {
+      "id": "N1",
+      "type": "Narrative",
+      "flowRef": "intro-defn-proof",
+      "from": "T:Intro",
+      "to": "T:Def:Eigenvector",
+      "transitionText": "As a first step, we define eigenvectors.",
+      "context": { "language": "en" }
+    },
+    {
+      "id": "N2",
+      "type": "Narrative",
+      "flowRef": "intro-defn-proof",
+      "from": "T:Def:Eigenvector",
+      "to": "T:Thm:Spectral",
+      "transitionText": "With this definition in hand, we can state the spectral theorem.",
+      "context": { "language": "en" }
+    },
+    {
+      "id": "N3",
+      "type": "Narrative",
+      "flowRef": "intro-defn-proof",
+      "from": "T:Thm:Spectral",
+      "to": "V:Proof:Spectral",
+      "transitionText": "We now prove the theorem.",
+      "context": { "language": "en" }
+    },
+
+    {
+      "id": "W1",
+      "type": "Narrative",
+      "flowRef": "walkthrough",
+      "from": "T:Intro",
+      "to": "T:Ex:Diagonalization",
+      "transitionText": "Let’s see a concrete example before formalities.",
+      "context": { "language": "en" }
+    },
+    {
+      "id": "W2",
+      "type": "Narrative",
+      "flowRef": "walkthrough",
+      "from": "T:Ex:Diagonalization",
+      "to": "T:Def:Eigenvector",
+      "transitionText": "This motivates the formal definition.",
+      "context": { "language": "en" }
+    },
+    {
+      "id": "W3",
+      "type": "Narrative",
+      "flowRef": "walkthrough",
+      "from": "T:Def:Eigenvector",
+      "to": "T:Thm:Spectral",
+      "transitionText": "Now the theorem becomes natural.",
+      "context": { "language": "en" }
+    },
+    {
+      "id": "W4",
+      "type": "Narrative",
+      "flowRef": "walkthrough",
+      "from": "T:Thm:Spectral",
+      "to": "V:Proof:Spectral",
+      "transitionText": "Finally, the proof.",
+      "context": { "language": "en" }
+    },
+
+    {
+      "id": "S1",
+      "type": "Semantic",
+      "depKind": "prereq",
+      "from": "T:Def:Eigenvector",
+      "to": "T:Thm:Spectral"
+    },
+    {
+      "id": "S2",
+      "type": "Semantic",
+      "depKind": "illustrates",
+      "from": "T:Ex:Diagonalization",
+      "to": "T:Thm:Spectral"
+    }
+  ]
+}
